// This file is part of Hermes2D
//
// Hermes2D is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 2 of the License, or
// (at your option) any later version.
//
// Hermes2D is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Hermes2D.  If not, see <http://www.gnu.org/licenses/>.

#include "nox.h"

#ifdef HAVE_NOX

static Epetra_SerialComm seq_comm;

// NOX Problem Interface ///////////////////////////////////////////////////////////////////////////

/// A helper for NOX solver
///
/// @ingroup solvers
template<typename Scalar>
class HERMES_API NoxProblemInterface :
  public NOX::Epetra::Interface::Required,
  public NOX::Epetra::Interface::Jacobian,
  public NOX::Epetra::Interface::Preconditioner
{
public:
  NoxProblemInterface(DiscreteProblemInterface<Scalar>* problem);
  virtual ~NoxProblemInterface();

  /// Compute and return F
  virtual bool computeF(const Epetra_Vector &x, Epetra_Vector &f, FillType flag = Residual);
  /// Compute an explicit Jacobian
  virtual bool computeJacobian(const Epetra_Vector &x, Epetra_Operator &op);

  /// Computes a user supplied preconditioner based on input vector x.
  /// @return true if computation was successful.
  virtual bool computePreconditioner(const Epetra_Vector &x, Epetra_Operator &m,
                                     Teuchos::ParameterList *precParams = 0);

  // Return a reference to the Epetra_CrsMatrix with the Jacobian
  // that is generated by the Interface class.
  EpetraMatrix<Scalar> *get_jacobian() { return &jacobian; }

  // Return a reference to the Epetra_Vector with the initial guess
  // that is generated by the Interface class.
  EpetraVector<Scalar> *get_init_sln() { return &init_sln; }

  void set_init_sln(double *ic);

  /// Accessor for preconditioner
    Teuchos::RCP<Precond<Scalar> > get_precond() { return precond; }
  void set_precond(Teuchos::RCP<Precond<Scalar> > &pc);

  DiscreteProblemInterface<Scalar>* fep;           // finite element problem being solved

  EpetraVector<Scalar> init_sln;          // initial solution
  EpetraMatrix<Scalar> jacobian;          // jacobian (optional)
  Teuchos::RCP<Precond<Scalar> > precond;  // preconditioner (optional)

  void prealloc_jacobian();
};

template<typename Scalar>
NoxProblemInterface<Scalar>::NoxProblemInterface(DiscreteProblemInterface<Scalar>* problem)
{
  fep = problem;
  int ndof = fep->get_num_dofs();
  // allocate initial solution
  init_sln.alloc(ndof);
  if(!fep->is_matrix_free()) prealloc_jacobian();

  this->precond = Teuchos::null;
}

template<typename Scalar>
NoxProblemInterface<Scalar>::~NoxProblemInterface()
{
  init_sln.free();
  if(!fep->is_matrix_free()) jacobian.free();
}

template<typename Scalar>
void NoxProblemInterface<Scalar>::prealloc_jacobian()
{
  // preallocate jacobian structure
  fep->create_sparse_structure(&jacobian);
  // jacobian.finish();
}

template<typename Scalar>
void NoxProblemInterface<Scalar>::set_precond(Teuchos::RCP<Precond<Scalar> > &pc)
{
  precond = pc;
  prealloc_jacobian();
}

template<typename Scalar>
void NoxProblemInterface<Scalar>::set_init_sln(double *ic)
{
  int size = fep->get_num_dofs();
  int *idx = new int[size];
  for (int i = 0; i < size; i++) init_sln.set(i, ic[i]);
  delete [] idx;
}

template<typename Scalar>
bool NoxProblemInterface<Scalar>::computeF(const Epetra_Vector &x, Epetra_Vector &f, FillType flag)
{
  EpetraVector<Scalar> xx(x);  // wrap our structures around core Epetra objects
  EpetraVector<Scalar> rhs(f);

  rhs.zero();
  
  Scalar* coeff_vec = new Scalar[xx.length()];
  xx.extract(coeff_vec);
  fep->assemble(coeff_vec, NULL, &rhs); // NULL is for the global matrix.
  delete [] coeff_vec;
  
  return true;
}

template<typename Scalar>
bool NoxProblemInterface<Scalar>::computeJacobian(const Epetra_Vector &x, Epetra_Operator &op)
{
  Epetra_RowMatrix *jac = dynamic_cast<Epetra_RowMatrix *>(&op);
  assert(jac != NULL);

  EpetraVector<Scalar> xx(x);			// wrap our structures around core Epetra objects
  EpetraMatrix<Scalar> jacobian(*jac);

  jacobian.zero();
  
  Scalar* coeff_vec = new Scalar[xx.length()];
  xx.extract(coeff_vec);
  fep->assemble(coeff_vec, &jacobian, NULL); // NULL is for the right-hand side.
  delete [] coeff_vec;
  //jacobian.finish();

  return true;
}

/// Computes a user supplied preconditioner based on input vector x.
/// @return true if computation was successful.
template<typename Scalar>
bool NoxProblemInterface<Scalar>::computePreconditioner(const Epetra_Vector &x, Epetra_Operator &m,
                                                Teuchos::ParameterList *precParams)
{
  assert(precond != Teuchos::null);
  EpetraVector<Scalar> xx(x);			// wrap our structures around core Epetra objects

  jacobian.zero();
  
  Scalar* coeff_vec = new Scalar[xx.length()];
  xx.extract(coeff_vec);
  fep->assemble(coeff_vec, &jacobian, NULL);  // NULL is for the right-hand side.
  delete [] coeff_vec;
  //jacobian.finish();

  precond->create(&jacobian);
  precond->compute();
  m = *precond->get_obj();

  return true;
}

#endif

// NOX solver //////////////////////////////////////////////////////////////////////////////////////

template<typename Scalar>
NoxSolver<Scalar>::NoxSolver(DiscreteProblemInterface<Scalar>* problem) : IterSolver<Scalar>()
{
#ifdef HAVE_NOX
  // default values
  nl_dir = "Newton";
  output_flags = NOX::Utils::Error;
  // linear solver settings
  ls_type = "GMRES";
  ls_max_iters = 800;
  ls_tolerance = 1e-8;
  ls_sizeof_krylov_subspace = 50;
  precond_type = "None";
  // convergence test
  conv.max_iters = 10;
  conv.abs_resid = 1.0e-6;
  conv.rel_resid = 1.0e-2;
  conv.norm_type = NOX::Abstract::Vector::TwoNorm;
  conv.stype = NOX::StatusTest::NormF::Scaled;
  conv.update = 1.0e-5;
  conv.wrms_rtol = 1.0e-2;
  conv.wrms_atol = 1.0e-8;

  conv_flag.absresid = 1;
  conv_flag.relresid = 0;
  conv_flag.update = 0;
  conv_flag.wrms = 0;

  // Create the interface_ between the test problem and the nonlinear solver
  // This is created by the user using inheritance of the abstract base class:
  // NOX_Epetra_Interface
  interface_ = Teuchos::rcp(new NoxProblemInterface<Scalar>(problem));
#else
  error(NOX_NOT_COMPILED);
#endif
}
#ifdef HAVE_NOX
template<typename Scalar>
NoxSolver::NoxSolver(DiscreteProblemInterface *problem, unsigned message_type, const char* ls_type, const char* nl_dir, 
    double ls_tolerance,
    const char* precond_type,
    unsigned flag_absresid,
    double abs_resid,
    unsigned flag_relresid,
    double rel_resid,
    int max_iters,
    double update,
    int ls_max_iters,
    int ls_sizeof_krylov_subspace,
    NOX::Abstract::Vector::NormType norm_type,
    NOX::StatusTest::NormF::ScaleType stype,
    double wrms_rtol,
    double wrms_atol,
    unsigned flag_update,
    unsigned flag_wrms
   ) {
  // default values
  this->nl_dir = nl_dir;
  output_flags = message_type;
  // linear solver settings
  this->ls_type = ls_type;
  this->ls_max_iters = ls_max_iters;
  this->ls_tolerance = ls_tolerance;
  this->ls_sizeof_krylov_subspace = ls_sizeof_krylov_subspace;
  this->precond_type = precond_type;
  // convergence test
  this->conv.max_iters = max_iters;
  this->conv.abs_resid = abs_resid;
  this->conv.rel_resid = rel_resid;
  this->conv.norm_type = norm_type;
  this->conv.stype = stype;
  this->conv.update = update;
  this->conv.wrms_rtol = wrms_rtol;
  this->conv.wrms_atol = wrms_atol;

  this->conv_flag.absresid = flag_absresid;
  this->conv_flag.relresid = flag_relresid;
  this->conv_flag.update = flag_update;
  this->conv_flag.wrms = flag_wrms;

  // Create the interface_ between the test problem and the nonlinear solver
  // This is created by the user using inheritance of the abstract base class:
  // NOX_Epetra_Interface
  interface_ = Teuchos::rcp(new NoxProblemInterface<Scalar>(problem));
}

#endif

template<typename Scalar>
NoxSolver<Scalar>::~NoxSolver()
{
#ifdef HAVE_NOX
  // FIXME: this does not destroy the "interface_", and Trilinos 
  // complains at closing main.cpp.
  interface_->fep->invalidate_matrix();
#endif
}

#ifdef HAVE_TEUCHOS

template<typename Scalar>
  void NoxSolver<Scalar>::set_precond(Teuchos::RCP<Precond<Scalar> > &pc)
  {
  #ifdef HAVE_NOX
    this->precond_yes = true;
    interface_->set_precond(pc);
  #endif
  }
#endif
  
template<typename Scalar>
void NoxSolver<Scalar>::set_precond(const char *pc)
{
#ifdef HAVE_NOX
  this->precond_yes = true;
  precond_type = pc;
#endif
}

template<typename Scalar>
bool NoxSolver<Scalar>::set_init_sln(double *ic)
{
#ifdef HAVE_NOX
  interface_->set_init_sln(ic);
  return true;
#else
  return false;
#endif
}

template<typename Scalar>
bool NoxSolver<Scalar>::set_init_sln(EpetraVector<Scalar> *ic)
{
#ifdef HAVE_NOX
  double *vals;
  ic->vec->ExtractView(&vals);
  interface_->set_init_sln(vals);
  return true;
#else
  return false;
#endif
}

#ifdef HAVE_NOX
template<>
void NoxSolver<double>::get_final_solution(Teuchos::RCP<NOX::Solver::Generic> & solver){
       const NOX::Epetra::Group &f_grp =
       dynamic_cast<const NOX::Epetra::Group &>(solver->getSolutionGroup());
       const Epetra_Vector &f_sln =
       (dynamic_cast<const NOX::Epetra::Vector &>(f_grp.getX())).getEpetraVector();
       // extract solution
       int n = interface_->fep->get_num_dofs();
       delete [] this->sln;
       this->sln = new double[n];
       memset(this->sln, 0, n * sizeof(double));
       f_sln.ExtractCopy(this->sln);
}

template<>
void NoxSolver<std::complex<double> >::get_final_solution(Teuchos::RCP<NOX::Solver::Generic> & solver){
       // extract solution
       int n = interface_->fep->get_num_dofs();
       delete [] this->sln;
       this->sln = new std::complex<double>[n];
       memset(this->sln, 0, n * sizeof(std::complex<double>));
}
#endif

template<typename Scalar>
bool NoxSolver<Scalar>::solve()
{
#ifdef HAVE_NOX
   // Create the top level parameter list
   Teuchos::RCP<Teuchos::ParameterList> nl_pars_ptr = Teuchos::rcp(new Teuchos::ParameterList);
   Teuchos::ParameterList &nl_pars = *nl_pars_ptr.get();

   // Set the nonlinear solver method
   nl_pars.set("Nonlinear Solver", "Line Search Based");

   // Set the printing parameters in the "Printing" sublist
   Teuchos::ParameterList &print_pars = nl_pars.sublist("Printing");
   print_pars.set("Output Information", output_flags);

   // Sublist for line search
   Teuchos::ParameterList &search_pars = nl_pars.sublist("Line Search");
   search_pars.set("Method", "Full Step");

   // Sublist for direction
   Teuchos::ParameterList &dir_pars = nl_pars.sublist("Direction");
   dir_pars.set("Method", nl_dir);
   Teuchos::ParameterList &newton_pars = dir_pars.sublist(nl_dir);
   
   if(strcmp(nl_dir, "Newton") == 0)
     newton_pars.set("Forcing Term Method", "Constant");
   
   // Sublist for linear solver for the Newton method
   Teuchos::ParameterList &ls_pars = newton_pars.sublist("Linear Solver");
   ls_pars.set("Aztec Solver", ls_type);
   ls_pars.set("Max Iterations", ls_max_iters);
   ls_pars.set("Tolerance", ls_tolerance);
   ls_pars.set("Size of Krylov Subspace", ls_sizeof_krylov_subspace);
   // TODO: parametrize me.
   ls_pars.set("Preconditioner Reuse Policy", "Recompute");
   ls_pars.set("Output Frequency", AZ_all);
   
   // precond stuff
   Teuchos::RCP<Precond<Scalar> > precond = interface_->get_precond();
   if(this->precond_yes == false)
     ls_pars.set("Preconditioner", "None");
   else 
     if(interface_->fep->is_matrix_free()) 
       ls_pars.set("Preconditioner", "User Defined");
     else {
       if(strcasecmp(precond_type, "ML") == 0)
         ls_pars.set("Preconditioner", "ML");
       else 
         if(strcasecmp(precond_type, "Ifpack") == 0)
           ls_pars.set("Preconditioner", "Ifpack");
         else {
           warn("Unsupported type of preconditioner.");
           ls_pars.set("Preconditioner", "None");
         }
     }
     
     // TODO: Parametrize me.
     ls_pars.set("Max Age Of Prec", 999);

     Teuchos::RCP<NOX::Epetra::Interface::Required> i_req = interface_;
     Teuchos::RCP<NOX::Epetra::Interface::Jacobian> i_jac = interface_;
     Teuchos::RCP<NOX::Epetra::Interface::Preconditioner> i_prec = interface_;
     Teuchos::RCP<Epetra_RowMatrix> jac_mat;
     Teuchos::RCP<NOX::Epetra::LinearSystemAztecOO> lin_sys;

     NOX::Epetra::Vector init_sln(*interface_->get_init_sln()->vec);
     
     if(interface_->fep->is_matrix_free()) {
       // Matrix<Scalar>-Free (Epetra_Operator)
       if(precond == Teuchos::null) {
         Teuchos::RCP<NOX::Epetra::MatrixFree> mf = 
         Teuchos::rcp(new NOX::Epetra::MatrixFree(print_pars, interface_, init_sln));
         i_jac = mf;
         lin_sys = Teuchos::rcp(new NOX::Epetra::LinearSystemAztecOO(print_pars, ls_pars, i_req,
         i_jac, mf, init_sln));
       }
       else {
         const Teuchos::RCP<Epetra_Operator> pc = precond;
         lin_sys = Teuchos::rcp(new NOX::Epetra::LinearSystemAztecOO(print_pars, ls_pars, i_req,
         i_prec, pc, init_sln));
       }
     }
     else {  // not Matrix<Scalar> Free
       // Create the Epetra_RowMatrix.
       jac_mat = Teuchos::rcp(interface_->get_jacobian()->mat);
       i_jac = interface_;
       lin_sys = Teuchos::rcp(new NOX::Epetra::LinearSystemAztecOO(print_pars, ls_pars, i_req,
            i_jac, jac_mat, init_sln));
     }

     // Create the Group
     Teuchos::RCP<NOX::Epetra::Group> grp = 
              Teuchos::rcp(new NOX::Epetra::Group(print_pars, i_req, init_sln, lin_sys));

     // Create convergence tests
     Teuchos::RCP<NOX::StatusTest::Combo> converged =
        Teuchos::rcp(new NOX::StatusTest::Combo(NOX::StatusTest::Combo::AND));

     if(conv_flag.absresid) {
       Teuchos::RCP<NOX::StatusTest::NormF> absresid =
                Teuchos::rcp(new NOX::StatusTest::NormF(conv.abs_resid, conv.norm_type, conv.stype));
       converged->addStatusTest(absresid);
     }

     if(conv_flag.relresid) {
       Teuchos::RCP<NOX::StatusTest::NormF> relresid = 
                Teuchos::rcp(new NOX::StatusTest::NormF(*grp.get(), conv.rel_resid));
       converged->addStatusTest(relresid);
     }

     if(conv_flag.update) {
       Teuchos::RCP<NOX::StatusTest::NormUpdate> update = 
                Teuchos::rcp(new NOX::StatusTest::NormUpdate(conv.update));
       converged->addStatusTest(update);
     }

     if(conv_flag.wrms) {
       Teuchos::RCP<NOX::StatusTest::NormWRMS> wrms =
              Teuchos::rcp(new NOX::StatusTest::NormWRMS(conv.wrms_rtol, conv.wrms_atol));
       converged->addStatusTest(wrms);
     }
     
     Teuchos::RCP<NOX::StatusTest::MaxIters> maxiters = 
            Teuchos::rcp(new NOX::StatusTest::MaxIters(conv.max_iters));

     Teuchos::RCP<NOX::StatusTest::FiniteValue> fv = 
            Teuchos::rcp(new NOX::StatusTest::FiniteValue);

     Teuchos::RCP<NOX::StatusTest::Combo> cmb = 
            Teuchos::rcp(new NOX::StatusTest::Combo(NOX::StatusTest::Combo::OR));

     cmb->addStatusTest(fv);
     cmb->addStatusTest(converged);
     cmb->addStatusTest(maxiters);

     Teuchos::RCP<Teuchos::ParameterList> final_pars = nl_pars_ptr;

     // Create the method
     Teuchos::RCP<NOX::Solver::Generic> solver = NOX::Solver::buildSolver(grp, cmb, final_pars);


     /// Solve.
     NOX::StatusTest::StatusType status = solver->solve();


     if(!interface_->fep->is_matrix_free())
       jac_mat.release();	// release the ownership (we take care of jac_mat by ourselves)

     bool success;
     if(status == NOX::StatusTest::Converged) {
       num_iters = solver->getNumIterations();
       residual = solver->getSolutionGroup().getNormF();
       num_lin_iters = final_pars->sublist("Direction").sublist(nl_dir).sublist("Linear Solver").sublist("Output").get("Total Number of Linear Iterations", -1);
       achieved_tol = final_pars->sublist("Direction").sublist(nl_dir).sublist("Linear Solver").sublist("Output").get("Achieved Tolerance", 0.0);

       // Get the Epetra_Vector with the final solution from the solver
       get_final_solution(solver);
       success = true;
     }
     else { // not converged
       num_iters = -1;
       success = false;
     }
     return success;
#else
     return false;
#endif
}
